#!/usr/bin/python
#
# Resize a gro file by isotropically resizing its box vectors and translating the center of mass of each molecule
# The input can either be a new total volume or a new box vector
# NOTE: THE VECTOR MUST BE ENCASED IN QUOTATION MARKS WHEN ENTERED 
#
# Copyright Michael R. Shirts, University of Virginia, 2014
#

import numpy # numerical array library
import pymbar # multistate Bennett acceptance ratio
from pymbar import timeseries # timeseries analysis
from optparse import OptionParser # for parsing command-line options
import pdb

#=============================================================================================
# INPUT VARIABLES
#=============================================================================================
#Gro file to be resized
# polymorph B'~ polymorph B
# mol_name is the name of the molecule in the .gro files
mol_name = 'BNZ'
# nam is the number of atoms per molecule
nam = int(12)
# nmu is the number of molecules per unit cell
nmu = 4

#=============================================================================================
# OUTPUT VARIABLES
#=============================================================================================
# This script produces a gro file with the resized dimensions and molecules


parser = OptionParser()
parser.add_option('-V', '--volume', dest = 'volume', help = 'Final Volume', default='-1.0') #Final volume in cubic angstroms
parser.add_option('-G', '--gro', dest = 'grofile', help = 'Gromacs File') #.gro file to be resized
parser.add_option('-M', '--molecule', dest = 'molname', help = 'Name of the molecule in the gro file', default='BNZ')
parser.add_option('-n', '--atoms', dest = 'numatoms', help = 'number of atoms in each molecule', default='12')
parser.add_option('-u', '--unit', dest = 'nummol', help = 'number of molecules in unit cell',default='4')
parser.add_option('-v', '--vector', dest = 'vector', help = 'New box vector', default = '0 0 0 0 0 0 0 0 0')
(options, args) = parser.parse_args()
final_volume = float(options.volume)
mol_name = options.molname
num_atoms = int(options.numatoms)
num_mol = int(options.nummol)
boxvect = options.vector
fname = options.grofile

#=============================================================================================
# Ensure that all inputs are correct
#=============================================================================================
if  final_volume < 0.0 and boxvect == 'vect':
    print "Invalid final volume: " + str(final_volume)
    sys.exit()
if mol_name == "":
    print "Please enter an abbreviated molecule name"
    sys.exit()
if num_atoms < 0:
    print "Invalid number of atoms per molecule: " + str(num_atoms)
    sys.exit()
if num_mol < 0:
    print "Invalid number of molecules per unit cell: " + str(num_mol)
    sys.exit()
if fname == "":
    print "Please enter a gro file name"
    sys.exit()

#=============================================================================================
# Generate atom location arrays with all polymorph atom coordinates
#=============================================================================================
# Read in the new box vector 
inputvect = numpy.zeros(9,float)
for i,token in enumerate(boxvect.split()):
    inputvect[i]=float(token) 

# Read in input files
fname = options.grofile
infile = open(fname, 'r')
lines = filter(None, (line.rstrip() for line in infile))
infile.close()
print "loading " + fname

# Read in the total number of atoms in the system (should be the only item on the second line of the .gro file)
if len(lines[1].split()) == 1:
    # na is the number of total atoms
    na = int(lines[1].split()[0])
    # nm is the number of total molecules
    nm = na/(num_atoms)
else:
    sys.exit('Unexpected .gro file format')

# Read in atom coordinate data (starts on 3rd line of the .gro file)
# acoordA and acoordB are the atom coordinates for polymorphs A and B
line = 2
mol = 0
old_xyz_position = numpy.zeros((nm,3,nam))	#Original xyz positions of all the atoms
new_xyz_position = numpy.zeros((nm,3,nam))	#Translated xyz positions of all the atoms
old_crystal_position = numpy.zeros((nm,3,nam))      #Original crystal positions of all the atoms
new_crystal_position = numpy.zeros((nm,3,nam))      #Translated crystal positions of all the atoms

while mol < nm:
    acounter = 0
    while acounter < nam:
        old_xyz_position[mol,0,acounter] = float(lines[line].split()[3])
        old_xyz_position[mol,1,acounter] = float(lines[line].split()[4])
        old_xyz_position[mol,2,acounter] = float(lines[line].split()[5])
        line += 1
        acounter +=1
    mol += 1

#=============================================================================================
# CREATE THE TRANSFORMATION OPERATOR BETWEEN BASIS SETS
#=============================================================================================
old_crystal_basis = numpy.zeros([3,3],float)	#Old Matrix to take a crystal vector into xyz coordinates
new_crystal_basis = numpy.zeros([3,3],float)    #New Matrix to take a crystal vector into xyz coordinates
rref_matrix = numpy.zeros([3,6],float)		#Size-by-size matrix of both basis
transform_basis = numpy.zeros([3,3],float)      #Transformation operator to convert the old basis into the new basis
xyz_to_crystal = numpy.zeros([3,3],float)	#Matrix to take an xyz vector into crystal coordinates
tokens = lines[len(lines)-1].split()
oldvect=[]					#Original last line of the gro file
newvect=[]					#New last line of the gro file
#Read in the old crystal basis matrix (the last line of the .gro file)
for i,token in enumerate(tokens):
    if i == 0:
	old_crystal_basis[0,0]=float(token)
	new_crystal_basis[0,0]=float(inputvect[i])
    elif i==1:
	old_crystal_basis[1,1]=float(token)
	new_crystal_basis[1,1]=float(inputvect[i])
    elif i==2:
        old_crystal_basis[2,2]=float(token)
	new_crystal_basis[2,2]=float(inputvect[i])
    elif i==3:
        old_crystal_basis[0,1]=float(token)
	new_crystal_basis[0,1]=float(inputvect[i])
    elif i==4:
        old_crystal_basis[0,2]=float(token)
	new_crystal_basis[0,2]=float(inputvect[i])
    elif i==5:
        old_crystal_basis[1,0]=float(token)
	new_crystal_basis[1,0]=float(inputvect[i])
    elif i==6:
        old_crystal_basis[1,2]=float(token)
	new_crystal_basis[1,2]=float(inputvect[i])
    elif i==7:
        old_crystal_basis[2,0]=float(token)
	new_crystal_basis[2,0]=float(inputvect[i])
    elif i==8:
        old_crystal_basis[2,1]=float(token)
	new_crystal_basis[2,1]=float(inputvect[i])
    oldvect.append(token)
    newvect.append(str(round(inputvect[i],5))+" ")
#crystal_basis = numpy.transpose(crystal_basis)
#xyz_to_crystal = numpy.linalg.inv(crystal_basis)

#Create the new crystal basis matrix (if only a volume was specified)
if final_volume > 0.0:
    initial_volume = float(numpy.linalg.det(old_crystal_basis))
    scaling_param = (final_volume/initial_volume)**(1.0/3.0)
    new_crystal_basis = scaling_param*old_crystal_basis
    newvect=[];
    for token in oldvect:
        newvect.append(str(round(scaling_param*float(token),5)) + " ")

#Solve for the transformation operator
transform_basis = numpy.dot(numpy.linalg.inv(old_crystal_basis),new_crystal_basis)


"""
#=============================================================================================
# DETERMINE THE SCALING PARAMETERS
#=============================================================================================

#Calculate the initial volume of the gro file (if a volume is being used for scaling)
if final_volume > 0.0:
    initial_volume = float(numpy.linalg.det(crystal_basis))
    scaling_param_x = (final_volume/initial_volume)**(1.0/3.0)
    scaling_param_y = (final_volume/initial_volume)**(1.0/3.0)
    scaling_param_z = (final_volume/initial_volume)**(1.0/3.0)
    scaling_param = (final_volume/initial_volume)**(1.0/3.0)
elif boxvect != 'vect':
    scaling_param_x = (float(inputvect[0])/float(oldvect[0]))
    scaling_param_y = (float(inputvect[1])/float(oldvect[1]))
    scaling_param_z = (float(inputvect[2])/float(oldvect[2]))
else:
    print "WTF?"
    sys.exit()
print "x: " + str(scaling_param_x)
print "y: " + str(scaling_param_y)
print "z: " + str(scaling_param_z)
#Create the bottom line of the new gro file
newvect = [];
for i,token in enumerate(oldvect):
    if i==0 or i==5 or i==7:
	newvect.append(str(round(scaling_param_x*float(token),5)) + " ")
    elif i==1 or i==3 or i==8:
	newvect.append(str(round(scaling_param_y*float(token),5)) + " ")
    elif i==2 or i==4 or i==6:
	newvect.append(str(round(scaling_param_z*float(token),5)) + " ")
"""
#=============================================================================================
# CALCULATE THE CENTROID OF EACH MOLECULE
#=============================================================================================

w = numpy.ones((nam,1))*(1.0/nam)
centroid_xyz = numpy.zeros((nm,3,1))
centroid_crystal=numpy.zeros((nm,3,1))
for mol in range(nm):
    centroid_xyz[mol,:,:] = numpy.dot(old_xyz_position[mol,:,:], w)


"""
#=============================================================================================
# Convert molecule and centroid xyz positions to crystal positions
#=============================================================================================
mol = 0
while mol < nm:
    old_crystal_position[mol,:,:] = xyz_to_crystal.dot(old_xyz_position[mol,:,:])
    #centroid_crystal[mol,:,:] = xyz_to_crystal.dot(centroid_crystal[mol,:,:])
    centroid_crystal[mol,:,:] = xyz_to_crystal.dot(centroid_xyz[mol,:,:])
    mol += 1


#=============================================================================================
# Calculate the new crystal position for each molecule and each atom
#=============================================================================================
mol = 0
while mol < nm:
    #new_crystal_position[mol,:,:] = old_crystal_position[mol,:,:]+(scaling_param-1.0)*centroid_crystal[mol,:,:]
    new_crystal_position[mol,0,:] = old_crystal_position[mol,0,:]+(scaling_param_x-1.0)*centroid_crystal[mol,0,:]
    new_crystal_position[mol,1,:] = old_crystal_position[mol,1,:]+(scaling_param_y-1.0)*centroid_crystal[mol,1,:]
    new_crystal_position[mol,2,:] = old_crystal_position[mol,2,:]+(scaling_param_z-1.0)*centroid_crystal[mol,2,:]

    mol += 1

#=============================================================================================
# Convert new molecule crystal positions to xyz positions
#=============================================================================================
mol = 0
while mol < nm:
    new_xyz_position[mol,:,:] = crystal_basis.dot(new_crystal_position[mol,:,:])
    mol += 1
"""

#=============================================================================================
# Calculate the new xyz position for each molecule and each atom
#=============================================================================================
mol = 0
while mol < nm:
    new_xyz_position[mol,:,:] = (old_xyz_position[mol,:,:]-centroid_xyz[mol,:,:])+numpy.dot(transform_basis,centroid_xyz[mol,:,:])
    mol += 1



#=============================================================================================
# Output the new gro file
#=============================================================================================
# Write output .gro file
# tacount is the total atom count
outfile = open(fname, 'w')
outfile.write(lines[0])
outfile.write('\n')
outfile.write(lines[1])
outfile.write('\n')
tacount = 0
for mol in range(nm):
    for atom in range(int(nam)):
    # mcount is the current molecule tracker
        mcount = mol + 1
        tacount += 1
        x = round(new_xyz_position[mol,0,atom],5)
        y = round(new_xyz_position[mol,1,atom],5)
        z = round(new_xyz_position[mol,2,atom],5)
	if x < 0.0:
	    xstr = '   ' + "%.5f" % x
	elif x == 0.0:
	    xstr = '    0.00000'
	else:
	    xstr = '    ' + "%.5f" % x
	if y < 0.0:
            ystr = '   ' + "%.5f" % y
	elif y == 0.0:
	    ystr = '    0.00000'
        else:
            ystr = '    ' + "%.5f" % y
	if z < 0.0:
            zstr = '   ' + "%.5f" % z
	elif z == 0.0:
	    zstr = '    0.00000'
        else:
            zstr = '    ' + "%.5f" % z

        #xstr = '%(x) 10g' %vars()
        #ystr = '%(y) 10g' %vars()
        #zstr = '%(z) 10g' %vars()
        line = str(mcount).rjust(5) + mol_name + lines[tacount+1].split()[1].rjust(7) + str(tacount).rjust(5) + xstr + ystr + zstr + '\n'
        outfile.write(line)
outfile.write("   " + '   '.join(newvect))
outfile.write('\n')  # make sure the file ends on a newline
outfile.close()
